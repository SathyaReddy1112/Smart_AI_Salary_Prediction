Smart AI Powered Employee Salary Prediction
Project Overview
This project provides a "Smart AI Powered Employee Salary Prediction" web application built using Streamlit. It leverages a trained machine learning model to predict average employee salaries based on various job details and integrates with the Google Gemini API to provide intelligent, natural language insights and explanations for the predictions.

Features
Salary Prediction: Predicts average employee salaries based on input features such as company rating, employee age, expected salary range, job type, location, industry, sector, and required skills (Python, R, Spark, AWS, Excel).

Interactive UI: A user-friendly web interface developed with Streamlit for easy input and prediction.

AI-Powered Insights (Gemini API): After a salary prediction is made, the application utilizes the Google Gemini API to generate a concise explanation of the contributing factors and offers actionable insights or career growth suggestions.

Comprehensive ML Pipeline: The backend includes a robust machine learning pipeline covering data loading, cleaning, EDA, preprocessing, model training with multiple algorithms (Linear Regression, Decision Tree, Random Forest, XGBoost), cross-validation, and model persistence.

Custom Styling: Enhanced UI/UX with custom CSS for a modern and visually appealing design, including gradients, card-like sections, and subtle animations.

Project Structure
employee-salary-prediction/
├── .ipynb_checkpoints/      # Folder for Jupyter notebook checkpoints
├── app.py                   # The main Streamlit application script
├── model_evaluation_report.csv # CSV file containing model evaluation metrics
├── README.md                # This README file
├── requirements.txt         # List of Python dependencies
├── salary_data_cleaned.csv  # The cleaned dataset
├── salary_model_training.ipynb # Jupyter notebook for model training and experimentation
└── salary_predictor_model.pkl # The pre-trained machine learning pipeline

app.py: The main Streamlit application script containing the frontend UI, model loading, prediction logic, and Gemini API integration.
salary_data_cleaned.csv: The cleaned dataset used for training the machine learning model and populating dropdown options in the Streamlit app.

salary_predictor_model.pkl: The pre-trained machine learning pipeline (including preprocessing steps and the best-performing regression model) saved using joblib. This file is loaded by app.py for making predictions.

.ipynb_checkpoints/: A hidden folder created by Jupyter for saving notebook checkpoints.

model_evaluation_report.csv: A CSV file generated by the model training script, containing the performance metrics of the evaluated models.

README.md: This markdown file providing an overview, setup instructions, and usage guide for the project.

requirements.txt: A text file listing all the Python libraries and their versions required to run the project.

salary_model_training.ipynb: A Jupyter Notebook file that likely contains the detailed steps for data exploration, preprocessing, model building, and evaluation.

Setup and Installation
Follow these steps to set up and run the project locally:

Clone the Repository (or create the project structure):
If you have a Git repository, clone it:

git clone <your-repo-url>
cd employee-salary-prediction

Otherwise, create the employee-salary-prediction directory and place app.py, salary_data_cleaned.csv, salary_predictor_model.pkl, requirements.txt, README.md, model_evaluation_report.csv, and salary_model_training.ipynb inside it.

Create a Virtual Environment (Recommended):

python -m venv venv

Activate the Virtual Environment:

Windows:

.\venv\Scripts\activate

macOS/Linux:

source venv/bin/activate

Install Dependencies:
Install all the required Python packages using the requirements.txt file:

pip install -r requirements.txt

(Alternatively, you can manually install them: pip install streamlit pandas joblib scikit-learn xgboost google-generativeai)

Google Gemini API Key:
The app.py currently has the Gemini API key hardcoded. For production environments or sharing, it's strongly recommended to use Streamlit Secrets:

Create a .streamlit folder in your project root.

Inside .streamlit, create a secrets.toml file.

Add your API key to secrets.toml:

gemini_api_key = "YOUR_GEMINI_API_KEY_HERE"

Then, in app.py, change GOOGLE_API_KEY = "YOUR_API_KEY" to GOOGLE_API_KEY = st.secrets["gemini_api_key"].

Usage
Ensure Model and Data Files are Present:
Make sure salary_data_cleaned.csv and salary_predictor_model.pkl are in the same directory as app.py. The salary_predictor_model.pkl file is generated after running the model training script.

Run the Streamlit Application:
Navigate to the project's root directory (employee-salary-prediction/) in your terminal and run:

streamlit run app.py

Access the Application:
Your web browser will automatically open to the Streamlit application (usually at http://localhost:8501).

Make Predictions:
Fill in the job details in the interactive form and click the "Predict Salary" button to get an estimated average salary and AI-powered insights.

Gemini API Integration Details
The Gemini API is used to provide natural language explanations and actionable insights about the predicted salary. When a prediction is made, the input job details and the predicted salary are sent to the gemini-2.0-flash model. The model then generates a textual explanation of the factors influencing the salary and offers career growth suggestions based on the provided data.

Contributing
Contributions are welcome! If you have suggestions for improvements, bug fixes, or new features, please feel free to:

Fork the repository.

Create a new branch (git checkout -b feature/your-feature-name).

Make your changes.

Commit your changes (git commit -m 'Add new feature').

Push to the branch (git push origin feature/your-feature-name).

Open a Pull Request.

License
This project is open-source and available under the MIT License. (You might need to create a LICENSE file in your project root if you choose this license).